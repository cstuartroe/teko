// Primitives and Casting

// side note - ints and reals are arbitrary precision. no binary rounding hanky panky in the reals.
int n = 3;
real x = n.; // 3.0
str s = n$; // "3"
bool b = true;
!b; // false

n + 2; // 5
n + 2.; // error - no implicit casts
n. + 2.; // 5.0
n + "test"; // error again, same reason
n$ + "test"; // "3test"
2 == 2.0; // error
2. == 2.0; // true

comp z = 3 - 2i; // complex numbers are a primitive type
typeof(3); // int
typeof(2i); // comp
// current inconsistency - implicit casting needs to occur in complex number creation, hmm...

// Declaration

int n1;
typeof(n1); // int
n1 == 0; // error - not yet instantiated
n1 == 0.0; // error - wrong types
n1 = 5;
int n1; // error - already declared
real n1; // error again
real x1, x2; // multiple declaration is fine

// Arrays

int[] ns = [1,2,3];
ns[1]; // 2
typeof(ns); // int[]

// Lists

str{} l = {"a","b","c"};
str first : str{} rest = l;
first; // "a"
rest; // {"b","c"}
l:; // "a"
:l; // {"b","c"}
typeof(l); // str{}
l = "Z":l;
l; // {"Z","a","b","c"}
_:l = l; // _ diposes of value, as in Haskell
l; // {"a","b","c"}
l{0}; // error - linked lists don't have indexing

ns{}; // {1,2,3}

// Sets and Enums

int<> primes = <2,3,5,7,11,13,17,19>;
primes; // <7,13,2,19,3,11,5,17> idk yet what order you'd actually see, but point is sets are unordered
enum prime = primes~; // cast set to enumerated type
prime p = 3;
prime q = 4; // error
primes{}; // {7,13,2,19,3,11,5,17} again, no guaranteed order
is(prime, type); // true - enum <: type

// Dictionaries

{str:int} ages = {"Bob":42,"Alice":35};
ages{"Bob"}; // 42
ages{"Carol"} = 16;
typeof(ages); // {str:int}

// Tuples

(str,int) alice = ("Alice",35);
alice(0); // "Alice"
(str alice_name, int alice_age) = alice;
alice_name; // "Alice"
typeof(alice); // (str, int)

(int,real,str) things;
typeof(things(1)); // real
things(1); // error - not yet instantiated

// Structs

struct person = (str name, int age);
person; // (str name, int age)
person bob = person("Bob",42);
bob; // (name = "Bob", age = 42)
bob(0); // "Bob"
bob.name; // "Bob"
(str bob_name, int bob_age) = bob;
bob_name; // "Bob"
bob.json(); // {"name":"Bob","age":42}

is(bob,(str,int)); // true
is(bob,person); // true

struct <: type; // true - structs are a category of type
person <: type; // false
person <: struct; // false - struct is the type of person, not a superclass
person <: (str, int); // true
typeof(person); // struct
is(person, type); // true

person.labels; // {"name":str, "age":int}
typeof(person.labels); // {str:type}
person.order; // {"name","age"} structs are ordered like tuples
typeof(person.order); // str{}

struct body = (int nose ? 1, int eyes ? 2, int fingers ? 10);
alice = body();
alice; // (nose = 1, eyes = 2, fingers = 10)
carol = body(fingers = 12); // supports keyword arguments
carol; // (nose = 1, eyes = 2, fingers = 12)

// Control Structures

bool cond1 = ...;
bool cond2 = ...;
if (cond1) {
    ...
} else if (cond2) {
    ...
} else {
    ...
}

bool stop = false;
while (!stop) { // no surprises here
    ...
}

int[] nums = [1,4,18,831,12];
for (int num in nums) {
	...
}

for (int i in range(10)) { // see stdlib.to
	...
}

each (int num in nums{}) { // async loop - we'll see whether this gets implemented
	...
}

// Function declarations

int plusone(int n) = {
    return n + 1;
};
typeof(plusone); // int(int)

int plustwo(int n);

typeof(plustwo); // int(int)
plustwo.args; // (int n)
typeof(plustwo.args); // struct - indeed, all function arguments are simply structs!
plustwo.rt; // return type - int
typeof(plustwo.rt); // type
is(plustwo.rt, type); // true, obviously
is(plustwo.args, type); // true - struct <: type

plustwo = {return n + 2;}; // can define function on different line than declaration

void greet(str name, str greeting ? "Hello,") = { // default argument like Python
    println(greeting, name); // printing can take multiple arguments as in Python
};
typeof(greet); // void(str, str)

void greet(str name) = { // error - no overloading
    ...
};

// Classes and Inheritance

abstract class Pet { // abstract type as in Java
    private: // visibility sections as in C++
    str name; 

    public:
    str getName() = { return name; };
    void speak();
};

class Dog sub Pet {
    public:
    Dog(str _name) = {
        name = _name;
    };
    speak = { print("Arf!"); };
};

willis = Dog("Willis");
willis.getName(); // "Willis"
willis.name; // error - access prohibited

void call(Pet pet) = { 
    println("Here",pet.getName());
}

is(willis,Pet); // true
call(willis); // >> Here Willis

void addWillis((? super Dog){} doglist) { // Java-inspired type generics, clearly.
	doglist := willis;
}

Pet{} petlist = {};
int{} intlist = {};
addWillis(petlist); // fine
addWillis(intlist); // error