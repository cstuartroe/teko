// Primitives and Casting

// side note - ints and floats are arbitrary precision. no binary rounding hanky panky in the floats.
int n = 3;
float x = n.; // 3.0
str s = `n`; // "3"
bool b = true;
!b; // false

n + 2; // 5
n + 2.; // error - no implicit casts
n. + 2.; // 5.0
n + "test"; // error again, same reason
`n` + "test"; // "3test"
2 == 2.0; // error
2. == 2.0; // true

comp z = 3 - 2i; // complex numbers are a primitive type
typeof(3); // int
typeof(2i); // comp
// current inconsistency - implicit casting needs to occur in complex number creation, hmm...

// Declaration

int n1;
typeof(n1); // int
n1 == 0; // error - not yet instantiated
n1 == 0.0; // error - wrong types
n1 = 5;
int n1; // error - already declared
float n1; // error again
float x1, x2; // multiple declaration is fine

// Arrays

int[3] ns = [1,2,3];
ns[1]; // 2
typeof(ns); // int[3]

// Lists

str{} l = {"a","b","c"};
str first : str{} rest = l;
first; // "a"
rest; // {"b","c"}
l:; // "a"
:l; // {"b","c"}
typeof(l); // str{}
l := "Z";
l; // {"Z","a","b","c"}
_:l = l; // _ diposes of value, as in Haskell
l; // {"a","b","c"}
l{0}; // error - linked lists don't have indexing

ns{}; // {1,2,3}

// Strings as Char Lists

char head;
str tail;
head : tail = "test"; // str is secretly char{}, as in Haskell
head; // 't'
tail; // "est"
char{} letters = {'t','e','k','o'};
letters; // "teko"
typeof(letters); // str

// Sets and Enums

int<> primes = <2,3,5,7,11,13,17,19>;
primes; // <7,13,2,19,3,11,5,17> idk yet what order you'd actually see, but point is sets are unordered
type prime = primes~; // cast set to enumerated type
prime p = 3;
prime q = 4; // error
primes{}; // {7,13,2,19,3,11,5,17} again, no guaranteed order

// Dictionaries

{str:int} ages = {"Bob":42,"Alice":35};
ages{"Bob"}; // 42
ages{"Carol"} = 16;
typeof(ages); // {str:int}

// Tuples

(str,int) alice = ("Alice",35);
alice(0); // "Alice"
(str alice_name, int alice_age) = alice;
alice_name; // "Alice"
typeof(alice); // (str, int)

(int,float,str) things;
typeof(things(1)); // float
things(1); // error - not yet instantiated

// Structs

struct person = (str name, int age);
person; // (str name, int age)
person bob = person("Bob",42);
bob; // (name = "Bob", age = 42)
bob(0); // "Bob"
bob.name; // "Bob"
(str bob_name, int bob_age) = bob;
bob_name; // "Bob"
bob.json(); // {"name":"Bob","age":42}

is(bob,(str,int)); // true
is(bob,person); // true

struct <: type; // true - structs are a category of type
person <: type; // true
person <: struct; // false - struct is the type of person, not a superclass
person <: (str, int); // true
typeof(person); // struct

person.labels; // {"name":str, "age":int}
typeof(person.labels); // {str:type}
person.order; // {"name","age"} structs are ordered like tuples
typeof(person.order); // str{}

struct body = (int nose ? 1, int eyes ? 2, int fingers ? 10);
alice = body();
alice; // (nose = 1, eyes = 2, fingers = 10)
carol = body(fingers = 12); // supports keyword arguments
carol; // (nose = 1, eyes = 2, fingers = 12)

// Control Structures

for (int i = 0; i < 10; i++) {
	...
}

int[5] nums = [1,4,18,831,12];
for (int num in nums) { // error - can't loop through array
	...
}
for (int num in nums{}) { // good - must loop through list
	...
}
for (int i in range(10)) { // see stdlib.to
	...
}

each (int num in nums{}) { // async loop - we'll see whether this gets implemented
	...
}

bool stop = false;
while (!stop) { // no surprises here
	...
}

bool cond1 = ...;
bool cond2 = ...;
if (cond1) {
	...
} else if (cond2) {
	...
} else {
	...
}

// Function declarations

int plusone(int n) = {
    return n + 1;
};
typeof(plusone); // int(int)

int plustwo(int n);

typeof(plustwo); // int(int)
plustwo.args; // (int n)
typeof(plustwo.args); // struct - indeed, all function arguments are simply structs!
plustwo.rt; // return type - int
typeof(plustwo.rt); // type
is(plustwo.rt, type); // true, obviously
is(plustwo.args, type); // true - struct <: type

plustwo = {return n + 2;}; // can define function on different line than declaration

void greet(str name, str greeting ? "Hello,") = { // default argument like Python
    println(greeting, name); // printing can take multiple arguments as in Python
};
typeof(greet); // void(str, str)

void greet(str name) = { // error - no overloading
    ...
};

// Classes and Inheritance

abstract class Pet { // abstract type as in Java
    private: // visibility sections as in C++
    str name; 

    public:
    str getName() = { return name; };
    void speak();
};

class Dog sub Pet {
    public:
    Dog(str _name) = {
        name = _name;
    };
    speak = { print("Arf!"); };
};

void call(<? sub Pet> pet) = { // Java-inspired type generics, clearly.
    println("Here",pet.getName());
}

willis = Dog("Willis");
willis.getName(); // "Willis"
willis.name; // error - access prohibited
is(willis,Pet); // true
call(willis); // >> Here Willis
