\documentclass{article} 
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}
\setlength\parindent{0pt}
\usepackage{fancyhdr}
\usepackage{centernot}
\usepackage{verbatim}
\usepackage{xcolor}
\pagestyle{fancy}
\lhead{Conor Stuart Roe}
\rhead{\today}

\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}

\title{Specification for the Teko Programming Language}
\author{Conor Stuart Roe}
\date{\today}

\begin{document}
\thispagestyle{empty}
\maketitle

\section{Overview}

Teko is a high-level, statically typed scripting language that is primarily interpreted. It follows an object-oriented and imperative programming paradigm. It is intended to offer a full type system with user-defined classes, class hierarchies, and generics, much like Java, and can be rigorously statically type checked. Its high-level architecture offers a variety of advanced data types, such as complex numbers, bytestrings, maps, and structs as primary types, and other features like asynchronous loops easily available. It follows a typical C family syntax; at a glance, Teko looks most like Java, with some syntactic features inspired by Javascript, C++, or Python. \\

Teko was created in 2018 by Conor Stuart Roe.

\section{Lexical and Syntactic Structure}

Teko lexical and syntactic structure are defined by the BNF descriptions below. := indicates definition of a nonterminal, pipe $\|$ indicates options, parentheses () indicate optional elements, and asterisk * indicates occurrence zero or more times. Angle brackets $<>$ may be used to write English descriptions. Literal characters are written with \code{code formatting}. Teko is not whitespace-sensitive, except with regard to parsing strings and line comments.

\subsection{Lexical Structure}

Teko token capture is greedy, so if two adjacent tokens could be mistaken as comprising a single token, they must be separated by whitespace. \\ \\

\textsc{Label} := \textsc{Alphabetical} ( \textsc{Alphanumeral} )* 

\begin{quote} $\bullet$ \textsc{Label}s are any sequence of alphanumeric characters beginning with an alphabetical character, excluding the following reserved words: \code{true}, \code{false}, \code{if}, \code{else}, \code{for}, \code{while}, \code{each}, \code{begin}, \code{let}, \code{class}, \code{in}, \code{void},\code{return}, \code{public}, \code{protected}, \code{private}, \code{readonly}, \code{typeof}. \end{quote}

\textsc{Int} := \textsc{Numeral} ( \textsc{Numeral} )* \\

\textsc{Real} := \textsc{Numeral} ( \textsc{Numeral} )* \code{.} ( \textsc{Numeral} )* 

\begin{quote} $\bullet$ \textsc{Real}s may end with a decimal point \code{.}, which implies a fractional part equal to zero. \end{quote}

\textsc{Bool} := \code{true} $\|$ \code{false} \\

\textsc{Char} := \code{\char13} \textsc{CharacterOrEscape} \code{\char13} $\|$ \code{\char13"\char13} $\|$ \code{\char13\textbackslash\char13\char13} \\

\textsc{String} := \code{"} (\textsc{CharacterOrEscape} $\|$ \code{\char13} $\|$ \code{\textbackslash"})* \code{"} \\

\textsc{Alphanumeral} := \textsc{Alphabetical} $\|$ \textsc{Numeral} \\

\textsc{CharacterOrEscape} := \textsc{Alphabetical} $\|$ \textsc{Numeral} $\|$ \textsc{Punct} $\|$ $<$space$>$ $\|$ \code{\textbackslash\textbackslash} $\|$ \code{\textbackslash n} $\|$ \code{\textbackslash t} 

\begin{quote} $\bullet$ Teko characters and strings may not contain literal tab or newline characters. \end{quote}

\textsc{Alphabetical} := (one of) \code{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\_} \\

\textsc{Numeral} := (one of) \code{0123456789} \\

\textsc{Punct} := (one of) \code{!\#\$\%\&()*+,-./:;<=>?@]\^{}\{|\}\~} \\

\subsection{Comment Structure}

Teko support C-style line comments, which begin with a double slash \code{//} and end at the next newline. \\

\subsection{Syntactic Structure}

Each Teko file consists of a single \textsc{CodeBlock}. \\ \\

\textsc{CodeBlock} := (\textsc{Line} \code{;} )* \\

\textsc{Line} := \textsc{VariableDeclaration} $\|$ \textsc{Assignment} $\|$ \textsc{Expression} $\|$ \textsc{IfStatement} $\|$ \textsc{WhileBlock} $\|$ \textsc{ForBlock} \\

\textsc{VariableDeclaration} := \code{let} \textsc{Declared} \textsc{SetInit} ( \code{,} \textsc{Declared} \textsc{SetInit})* $\|$ \textsc{Type} \textsc{Declared} (\textsc{SetInit}) ( \code{,} \textsc{Declared} (\textsc{SetInit}))* 

\begin{quote} $\bullet$ Teko permits the declaration of variables using the declarator \code{let} in place of a type, but doing so requires that all variables declared in this way be set to a value on the same line, so that type can be inferred. \end{quote}

\textsc{Declared} := \textsc{Label} (\textsc{Struct}) 

\begin{quote} $\bullet$ The presence of a struct after the label indicates that the new variable's type is a function with given return type, rather than simply storing a value of the given type. \end{quote}

\textsc{SetInit} := \code{=} \textsc{Expression} $\|$ \code{= \{} \textsc{CodeBlock} \code{\}} 

\begin{quote} $\bullet$ Initial setting of a variable's value differs from later assignments in that updating setters \code{+=}, \code{-=}, \code{*=}, \code{/=}, \code{\^{}=}, and \code{\%=} are not permitted. \end{quote}

\textsc{Type} := \textsc{NamedType} $\|$ \textsc{Type} \code{\{\}} $\|$ \textsc{Type} \code{<>} $\|$ \textsc{Type} \code{[]} $\|$ \code{\{} \textsc{Type} \code{:} \textsc{Type} \code{\}} $\|$ \code{(} ( \textsc{Type}, ( \code{,} \textsc{Type})* ) \code{)} $\|$ \textsc{StructType} \\

\textsc{NamedType} := \code{int} $\|$ \code{real} $\|$ \code{bool} $\|$ \code{char} $\|$ \code{str} $\|$ \code{enum} $\|$ \code{comp} $\|$ \code{bits} $\|$ $<$any \textsc{label} assigned to a type$>$ \\

\textsc{StructType} := \code{(} ( \textsc{StructTypeParam} ( \code{,} \textsc{StructTypeParam} )* ) \code{)} \\

\textsc{StructTypeParam} := \textsc{Type} \textsc{Label} ( \code{?} \textsc{Expression} ) \\

\textsc{Assignment} := \textsc{Label} \textsc{Setter} \textsc{Expression} $\|$ \textsc{Label} \code{= \{} \textsc{CodeBlock} \code{\}} \\

\textsc{Setter} := \code{=} $\|$ \code{+=} $\|$ \code{-=} $\|$ \code{*=} $\|$ \code{/=} $\|$ \code{\^{}=} $\|$ \code{\%=} \\

\textsc{Expression} := \textsc{Primitive} $\|$ \textsc{Composite} $\|$ \textsc{Label} (\textsc{Struct}) ( \code{.} \textsc{Label} (\textsc{Struct}) )* $\|$ \textsc{Expression} \textsc{Converter} $\|$ \textsc{Expression} \textsc{Slice} $\|$ \code{:} \textsc{Expression})

\begin{quote} $\bullet$ Expressions are the only syntactic units which evaluate to a value; in fact, in all contexts, expressions must evaluate to an appropriately-typed value. \end{quote}

\textsc{Primitive} := \textsc{Int} $\|$ \textsc{Real} $\|$ \textsc{Bool} $\|$ \textsc{Char} $\|$ \textsc{String} \\

\textsc{Composite} := \textsc{Array} $\|$ \textsc{List} $\|$ \textsc{Set} $\|$ \textsc{Enum} $\|$ \textsc{Map} $\|$ \textsc{Tuple} \\

\textsc{Array} := \code{[} ( \textsc{Expression} ( \code{,} \textsc{Expression} )* ) \code{]} \\

\textsc{List} := \code{\{} ( \textsc{Expression} ( \code{,} \textsc{Expression} )* ) \code{\}} \\

\textsc{Set} := \code{<} ( \textsc{Expression} ( \code{,} \textsc{Expression} )* ) \code{>}

\begin{quote} $\bullet$ In arrays, lists, and sets, collectively called the iterables, all contained expressions must evaluate to values of the same type, and the type of the iterable is derived from the type of the contained values. \end{quote}

\textsc{Enum} := \code{<} ( \textsc{Label} (\textsc{StructType}) ( \code{,} \textsc{Label} (\textsc{StructType}) )* ) \code{>} \\

\begin{quote} $\bullet$ In an enum, all labels must be undeclared, and their inclusion in the enum declares them. The \textsc{StructType} after a label, if present, allows that enum element to have parameters, much like a paramaterized data type in Haskell. \end{quote}

\textsc{Map} := \code{\{} ( \textsc{MapPair} (\code{,} \textsc{MapPair})* ) \code{\}} \\

\textsc{MapPair} := \textsc{Expression} \code{:} \textsc{Expression} \\

\textsc{Tuple} := \code{(} ( \textsc{Expression} ( \code{,} \textsc{Expression} )* ) \code{)} \\

\textsc{Struct} := \code{(} ( \textsc{StructParam} ( \code{,} \textsc{StructParam} )* ) \code{)} \\

\textsc{StructParam} := ( \textsc{Label} \code{=} ) \textsc{Expression}

\begin{quote} $\bullet$ All parameters without equals \code{=} must occur before all parameters with equals. \end{quote}

\textsc{Converter} := \code{.} $\|$ \code{\$} $\|$ \code{[]} $\|$ \code{\{\}} $\|$ \code{<>} \\

\textsc{Slice} := \code{[} \textsc{Expression} ( \code{:} \textsc{Expression} ) \code{]} \\

\textsc{IfStatement} := \code{if (} \textsc{Expression} \code{) \{} \textsc{CodeBlock} \code{\}} ( \code{else if (} \textsc{Expression} \code{) \{} \textsc{CodeBlock} \code{\}} )* ( \code{else \{} \textsc{CodeBlock} \code{\}} ) \\

\textsc{WhileBlock} := \code{while (} \textsc{Expression} \code{) \{} \textsc{CodeBlock} \code{\}} \\

\textsc{ForBlock} := \code{for (} \textsc{Type} \textsc{Label} \code{in} \textsc{Expression} \code{) \{} \textsc{CodeBlock} \code{\}}

\end{document}